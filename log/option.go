package log

import (
	"time"

	"github.com/liasece/micserver/log/core"
)

// options of log
type options struct {
	// NoConsole while remove console out put, default false.
	NoConsole bool
	// NoConsoleColor whil disable console output color, default false.
	NoConsoleColor bool
	// FilePaths is the log output file path, default none log file.
	FilePaths []string
	// RecordTimeLayout use for (time.Time).Format(layout string) record time field, default "060102-15:04:05",
	// will not be empty.
	RecordTimeLayout string
	// Level log record level limit, only higer thie level log can be get reach Writer, default SYS.
	Level Level
	// Name is thie logger name, default "".
	Name string
	// Topic is thie logger topic, default "".
	Topic string
	// AsyncWrite while asynchronously output the log record to Write, it may be more performance,
	// but if you exit(e.g. os.Exit(1), main() return) this process, it may be loss some log record,
	// because they didn't have time to Write and flush to file.
	AsyncWrite bool
	// AsyncWriteDuration only effective when AsyncWrite is true, this is time duration of asynchronously
	// check log output to write default 100ms.
	AsyncWriteDuration time.Duration
	// RedirectError duplicate stderr to log file, it will be call syscall.Dup2 in linux or syscall.DuplicateHandle
	// in windows, default false.
	RedirectError bool
	// RotateTimeLayout use of (time.Time).Format(layout string) to check if a roteta file is required.
	// default "", will disable rotate. Highest accuracy is minutes.
	RotateTimeLayout string

	Development bool
	AddCaller   bool
	AddStack    core.LevelEnabler
	CallerSkip  int
}

var _defaultoptions = options{
	RecordTimeLayout:   "060102-15:04:05",
	AsyncWriteDuration: time.Millisecond * 100,
}

// TOptions type of options
type TOptions struct {
	opts []optionFunc
}

func (o *TOptions) apply(log *Logger) {
	for _, v := range o.opts {
		v.apply(log)
	}
}

// Options func
func Options() *TOptions {
	return &TOptions{}
}

// An Option configures a Logger.
type Option interface {
	apply(*Logger)
}

// optionFunc wraps a func so it satisfies the Option interface.
type optionFunc func(*Logger)

func (f optionFunc) apply(log *Logger) {
	f(log)
}

// // WrapCore wraps or replaces the Logger's underlying core.Core.
//(o *TOptions) func WrapCore(f func(core.Core) core.Core) *TOptions {
// 	o.opts = append(o.opts, optionFunc(func(log *Logger) {
// 		log.core = f(log.core)
// 	})
// }

// Hooks registers functions which will be called each time the Logger writes
// out an Entry. Repeated use of Hooks is additive.
//
// Hooks are useful for simple side effects, like capturing metrics for the
// number of emitted logs. More complex side effects, including anything that
// requires access to the Entry's structured fields, should be implemented as
// a core.Core instead. See core.RegisterHooks for details.
//(o *TOptions) func Hooks(hooks ...func(core.Entry) error) *TOptions {
// 	o.opts = append(o.opts, optionFunc(func(log *Logger) {
// 		log.core = core.RegisterHooks(log.core, hooks...)
// 	})
// }

// Fields adds fields to the Logger.
func (o *TOptions) Fields(fs ...Field) *TOptions {
	o.opts = append(o.opts, optionFunc(func(log *Logger) {
		// log.core = log.core.With(fs)
	}))
	return o
}

// FilePaths add config to the Logger.
func (o *TOptions) FilePaths(path ...string) *TOptions {
	o.opts = append(o.opts, optionFunc(func(log *Logger) {
		// log.core = log.core.With(fs)
		log.FilePaths = append(log.FilePaths, path...)
	}))
	return o
}

// RotateTimeLayout add config to the Logger.
func (o *TOptions) RotateTimeLayout(value string) *TOptions {
	o.opts = append(o.opts, optionFunc(func(log *Logger) {
		// log.core = log.core.With(fs)
		log.RotateTimeLayout = value
	}))
	return o
}

// NoConsole add config to the Logger.
func (o *TOptions) NoConsole(value bool) *TOptions {
	o.opts = append(o.opts, optionFunc(func(log *Logger) {
		// log.core = log.core.With(fs)
		log.NoConsole = value
	}))
	return o
}

// NoConsoleColor add config to the Logger.
func (o *TOptions) NoConsoleColor(value bool) *TOptions {
	o.opts = append(o.opts, optionFunc(func(log *Logger) {
		// log.core = log.core.With(fs)
		log.NoConsoleColor = value
	}))
	return o
}

// AsyncWrite add config to the Logger.
func (o *TOptions) AsyncWrite(value bool) *TOptions {
	o.opts = append(o.opts, optionFunc(func(log *Logger) {
		// log.core = log.core.With(fs)
		log.AsyncWrite = value
	}))
	return o
}

// Level add config to the Logger.
func (o *TOptions) Level(value Level) *TOptions {
	o.opts = append(o.opts, optionFunc(func(log *Logger) {
		// log.core = log.core.With(fs)
		log.Level = value
	}))
	return o
}

// ErrorOutput sets the destination for errors generated by the Logger. Note
// that this option only affects internal errors; for sample code that sends
// error-level logs to a different location from info- and debug-level logs,
// see the package-level AdvancedConfiguration example.
//
// The supplied WriteSyncer must be safe for concurrent use. The Open and
// core.Lock functions are the simplest ways to protect files with a mutex.
//(o *TOptions) func ErrorOutput(w core.WriteSyncer) *TOptions {
// 	o.opts = append(o.opts, optionFunc(func(log *Logger) {
// 		log.errorOutput = w
// 	})
// }

// Development puts the logger in development mode, which makes DPanic-level
// logs panic instead of simply logging an error.
func (o *TOptions) Development() *TOptions {
	o.opts = append(o.opts, optionFunc(func(log *Logger) {
		log.Development = true
	}))
	return o
}

// AddCaller configures the Logger to annotate each message with the filename
// and line number of log's caller.  See also WithCaller.
func (o *TOptions) AddCaller() *TOptions {
	return o.WithCaller(true)
}

// WithCaller configures the Logger to annotate each message with the filename
// and line number of log's caller, or not, depending on the value of enabled.
// This is a generalized form of AddCaller.
func (o *TOptions) WithCaller(enabled bool) *TOptions {
	o.opts = append(o.opts, optionFunc(func(log *Logger) {
		log.AddCaller = enabled
	}))
	return o
}

// AddCallerSkip increases the number of callers skipped by caller annotation
// (as enabled by the AddCaller option). When building wrappers around the
// Logger and SugaredLogger, supplying this Option prevents log from always
// reporting the wrapper code as the caller.
func (o *TOptions) AddCallerSkip(skip int) *TOptions {
	o.opts = append(o.opts, optionFunc(func(log *Logger) {
		log.CallerSkip += skip
	}))
	return o
}

// // AddStacktrace configures the Logger to record a stack trace for all messages at
// // or above a given level.
//(o *TOptions) func AddStacktrace(lvl core.LevelEnabler) *TOptions {
// 	o.opts = append(o.opts, optionFunc(func(log *Logger) {
// 		log.addStack = lvl
// 	})
// }

// // IncreaseLevel increase the level of the logger. It has no effect if
// // the passed in level tries to decrease the level of the logger.
//(o *TOptions) func IncreaseLevel(lvl core.LevelEnabler) *TOptions {
// 	o.opts = append(o.opts, optionFunc(func(log *Logger) {
// 		core, err := core.NewIncreaseLevelCore(log.core, lvl)
// 		if err != nil {
// 			fmt.Fprintf(log.errorOutput, "failed to IncreaseLevel: %v\n", err)
// 		} else {
// 			log.core = core
// 		}
// 	})
// }
